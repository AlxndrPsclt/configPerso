# Update only the last added repo
update-repo() {
    for source in "$@"; do
        sudo apt-get update -o Dir::Etc::sourcelist="sources.list.d/${source}" \
        -o Dir::Etc::sourceparts="-" -o APT::Get::List-Cleanup="0"    
    done
}


# Marking and jumping functions
export MARKPATH=$HOME/.marks
function jump { 
    cd -P $MARKPATH/$1 2>/dev/null || echo "No such mark: $1"
}
function mark { 
    mkdir -p $MARKPATH; ln -s $(pwd) $MARKPATH/$1
}
function unmark { 
    rm -i $MARKPATH/$1 
}
function marks {
    ls -l $MARKPATH | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}
function sj {
    jump $(ls ~/.marks | fzf)
}
function svim {
    $EDITOR $(find . -type f | fzf)
}
function scd {
    cd $(fd --type d . / | fzf)
}




function undozip(){
  unzip -l "$1" |  awk 'BEGIN { OFS="" ; ORS="" } ; { for ( i=4; i<NF; i++ ) print $i " "; print $NF "\n" }' | xargs -I{} rm -r {}
}



function mcd() {
  mkdir -p "$1" && cd "$1";
}


n (){
  ($* ; notify-send "Command over" "$*")
}

dockerxecl() {
  docker exec -it $(docker ps -l -q) /bin/bash ;
}

#BLuetooth functions
bt_connect_headset() {
	echo -e "connect $BT_HEADSET_MAC\n" | bluetoothctl
}

bt_disconnect_headset() {
	echo -e "disconnect $BT_HEADSET_MAC\n" | bluetoothctl
}

bt_connect_bose_headset() {
	echo -e "connect $BT_BOSEONEARWIRELESS_MAC\n" | bluetoothctl
}

bt_disconnect_bose_headset() {
	echo -e "disconnect $BT_BOSEONEARWIRELESS_MAC\n" | bluetoothctl
}


bt_connect_speaker() {
	echo -e "connect $BT_SPEAKER_MAC\n" | bluetoothctl
}

bt_disconnect_speaker() {
	echo -e "disconnect $BT_SPEAKER_MAC\n" | bluetoothctl
}

bt_connect_anker_speaker() {
	echo -e "connect $BT_ANKER_SPEAKER_MAC\n" | bluetoothctl
}

bt_disconnect_speaker() {
	echo -e "disconnect $BT_ANKER_SPEAKER_MAC\n" | bluetoothctl
}

qrterm() {
	qrencode -t UTF8 -o /tmp/qr.txt "$@" && cat /tmp/qr.txt && rm /tmp/qr.txt
}

qrpass() {
	if [ -z $@ ];
		then
			echo "Asked for empty password"
		else
			pass "$@" | tr -d '\n' | qrencode -t UTF8 -o /tmp/qr.txt && cat /tmp/qr.txt && rm /tmp/qr.txt
	fi
}

vimo() {
	$EDITOR "$(fzf --border --height=25)"
}

smount() {
	sudo mount `ls /dev/sd* | fzf` /mnt/`ls /mnt/ | fzf`
}

sumount() {
	sudo umount /mnt/`ls /mnt/ | fzf`
}

paste2file() {
  DEFAULT=/tmp/clip.txt
	FILE=${1-$DEFAULT}
	DIR=$(dirname "${FILE}")
  if [ $FILE != $DEFAULT ] ; then
		if [ -f $FILE ] ; then
			if [ -w $FILE ]; then
					read -p "File $FILE already exists; overwrite? y/n`echo $'\n> '` " yn
					case $yn in
						[Yy]* ) echo "Overwrite file";;
						[Nn]* ) return ;;
					esac 
			else
				echo "The file $FILE exists and is not writable, using default: $DEFAULT"
				FILE="$DEFAULT"
			fi
		else
			if [ -w $DIR ]; then
				:
			else
				echo "The file $FILE does not exist and cannot be created, using default: $DEFAULT"
				FILE="$DEFAULT"
			fi
		fi
	fi
	xsel --output --clipboard > $FILE

	echo "Pasted clipboard content to $FILE"
	NUMBER_OF_PASTED_LINES=$(wc -l /tmp/clip.txt | awk '{print $1}')


  if [ $NUMBER_OF_PASTED_LINES -gt 6 ] ; then
		echo "..."
  fi
	tail -6 $FILE
  echo ""

}

vimall() {
	ag . -l | xargs bash -c '</dev/tty vim -p "$@"' ignoreme
}

screenrec() {
  output_filename="/home/alex/videos/screencapture/screencast-`date "+%Y-%m-%d_%H-%M-%S"`.mkv"
  notify-send "Starting screen recording to file: $output_filename"
	ffmpeg -video_size 1920x1080 -framerate 25 -f x11grab -i :0.0 -c:v libx264 -crf 30 -tune stillimage -preset ultrafast $output_filename
  notify-send "Screenrecording to $output_filename stopped"

	while true; do
		read -p  "Screen recording to $output_filename stopped, do you want to keep it? (y/n) " choice
		case "$choice" in 
			y|Y ) echo "Saved screencast to $output_filename"; break;;
			n|N ) rm $output_filename; echo "Nothing saved"; return 1;;
			* ) echo "invalid";;
		esac
	done

  read -e -i "$output_filename" -p "Do you want to rename it? " new_name
	if [[ -z "$new_name" ]];
	then
    echo "Done"
  else
    if [[ "$new_name" != "$output_filename" ]];
      then
				mv $output_filename $new_name
				echo "Renamed to $new_name"
		fi
		echo "Done"
  fi
}

rlk () {
	if [ -z $@ ];
		then
			link=$(readlink -f ./)
		else
			link=$(readlink -f $@)
	fi
echo $link | copy
echo "Copied: $link"
}
# fuzzy grep open via ag with line number
vg() {
  local file
  local line

  read -r file line <<<"$(ag --nobreak --noheading $@ | fzf -0 -1 | awk -F: '{print $1, $2}')"

  if [[ -n $file ]]
  then
     vim $file +$line
  fi
}

replace() {
	grep -rl "$1" | xargs -n 1 sed "s/$1/$2/g"
}
